# -*- coding: utf-8 -*-
"""Predictive Analysis - Socioeconomic Status and Academic Performance

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xnk5p2oZhUh8ANUaMZ05Xuj6zsgSEkp7

# Predictive Analysis

* Nama : Andi Engku Putribuana
* Email : andiengku1922@gmail.com
* Id-Dicoding : putribuana

## Dataset Information

> Data Cite: Cortez, Paulo. "Student Performance." UCI Machine Learning Repository, 2008, https://doi.org/10.24432/C5TG7T.\

* Data  merupakan kumpulan informasi yang dikumpulkan dari dua sekolah di Portugis mengenai prestasi siswa tingkat menengah. Data ini mencakup berbagai aspek, mulai dari nilai akademik siswa (terutama dalam mata pelajaran Matematika dan Bahasa Portugis), latar belakang demografis siswa (seperti usia, jenis kelamin), faktor sosial (misalnya, kondisi keluarga), hingga karakteristik sekolah itu sendiri.

## Business Understanding
* Menganalisis Pengaruh latar belakang sosial ekonomi terhadap prestasi (Analisis Regresi)
* Tujuan penelitian: Untuk mengetahui sejauh mana faktor sosial ekonomi berkontribusi pada kesenjangan prestasi dan merancang program-program yang dapat mengurangi dampak negatif dari latar belakang sosial ekonomi yang kurang menguntungkan.

## Data Collection
"""

#Import library
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import statsmodels.api as sm
import scipy.stats as stats

pip install ucimlrepo

from ucimlrepo import fetch_ucirepo

# fetch dataset
student_performance = fetch_ucirepo(id=320)

# data (as pandas dataframes)
X = student_performance.data.features
y = student_performance.data.targets

# metadata
print(student_performance.metadata)

# variable information
print(student_performance.variables)

"""Karena kita akan menganalisis latar belakang sosial ekonomi terhadap prestasi, berikut adalah kolom penting yang akan dilakukan analisis :

* Medu: Tingkat pendidikan ibu
* Fedu: Tingkat pendidikan ayah
* Mjob: Pekerjaan ibu
* Fjob: Pekerjaan ayah
* address: Alamat tempat tinggal siswa (urban atau rural)
* famsize: Ukuran keluarga
* Pstatus: Status parental (bersama atau terpisah)
* paid: Apakah siswa mengikuti kelas tambahan berbayar
* internet: Apakah siswa memiliki akses internet di rumah

Kolom yang merepresentasikan hasil akademik:
* G1: Nilai periode pertama
* G2: Nilai periode kedua
* G3: Nilai akhir
"""

import pandas as pd

column_names = ['sex', 'age', 'address', 'famsize', 'Pstatus', 'Medu', 'Fedu', 'Mjob', 'Fjob', 'paid', 'internet']

student = pd.DataFrame(data=X, columns=column_names)

student['G1'] = y['G1']
student['G2'] = y['G2']
student['G3'] = y['G3']

student.head()

"""## Data Understanding & Removing Outlier"""

student.shape

student.info()

student.describe()

"""## Handling Missing Value"""

student.isnull().sum()

"""## Handling Outliers"""

sns.boxplot(x=student['age'])

sns.boxplot(x=student['Medu'])

"""Mari kita asumsikan kolom "Medu" dan "Fedu" yg memeiliki skala 1-4 ini dengan keterangan berikut:
1. Pendidikan dasar
2. Pendidikan menengah pertama
3. Pendidikan menengah atas
4. Pendidikan tinggi
"""

sns.boxplot(x=student['Fedu'])

sns.boxplot(x=student['G1'])

sns.boxplot(x=student['G2'])

sns.boxplot(x=student['G3'])

"""Dari hasil pengamatan,

* kolom Usia (age): Kita mungkin tidak ingin menghapus usia siswa
* Nilai (G1, G2, G3): Bisa dilakukan capping atau mengganti outliers dengan median
"""

# Fungsi untuk mengganti outliers dengan median
def replace_outliers_with_median(student, column):
    Q1 = student[column].quantile(0.25)
    Q3 = student[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    median_value = student[column].median()
    # Ganti nilai outliers dengan median
    student[column] = np.where((student[column] < lower_bound) | (student[column] > upper_bound), median_value, student[column])
    return student

# Terapkan pada kolom 'G1', 'G2', dan 'G3'
student_fixed = student.copy()
for col in ['G1', 'G2', 'G3']:
    student_fixed = replace_outliers_with_median(student_fixed, col)

# Tampilkan hasil
student_fixed[['G1', 'G2', 'G3']].describe()

"""## Univariate Analysis"""

numerical_features = ['age', 'Medu', 'Fedu', 'G1', 'G2', 'G3']
categorical_features = ['sex', 'address', 'famsize', 'Pstatus', 'Mjob', 'Fjob', 'paid', 'internet']

"""### Categorical Features"""

feature = categorical_features[0]
count = student[feature].value_counts()
percent = 100*student[feature].value_counts(normalize=True)
student0 = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(student0)
count.plot(kind='bar', title=feature);

feature = categorical_features[1]
count = student[feature].value_counts()
percent = 100*student[feature].value_counts(normalize=True)
student1 = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(student1)
count.plot(kind='bar', title=feature);

feature = categorical_features[2]
count = student[feature].value_counts()
percent = 100*student[feature].value_counts(normalize=True)
student2 = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(student2)
count.plot(kind='bar', title=feature);

feature = categorical_features[3]
count = student[feature].value_counts()
percent = 100*student[feature].value_counts(normalize=True)
student3 = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(student3)
count.plot(kind='bar', title=feature);

feature = categorical_features[4]
count = student[feature].value_counts()
percent = 100*student[feature].value_counts(normalize=True)
student4 = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(student4)
count.plot(kind='bar', title=feature);

feature = categorical_features[5]
count = student[feature].value_counts()
percent = 100*student[feature].value_counts(normalize=True)
student5 = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(student5)
count.plot(kind='bar', title=feature);

feature = categorical_features[6]
count = student[feature].value_counts()
percent = 100*student[feature].value_counts(normalize=True)
student6 = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(student6)

count.plot(kind='bar', title=feature);

feature = categorical_features[7]
count = student[feature].value_counts()
percent = 100*student[feature].value_counts(normalize=True)
student7 = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(student7)

count.plot(kind='bar', title=feature);

"""### Numerical Fetaures"""

student.hist(bins=50, figsize=(20,15))
plt.show()

"""## Multivariate Analysis

### Categorical Features

Mari kita asumsikan untuk analisis Hubungan Antar Variabel Kategorikal dengan prestasi dan kolom "G3" sebagai target utama.
"""

plt.figure(figsize=(15, 10))

# Loop untuk setiap fitur kategorikal
for i, feature in enumerate(categorical_features):
    plt.subplot(3, 3, i + 1)

    # Visualisasi menggunakan bar plot
    sns.barplot(data=student, x=feature, y='G3', palette="Blues")

    # Menambahkan judul dan label
    plt.title(f'Prestasi Siswa (G3) Berdasarkan {feature}')
    plt.xticks(rotation=0)
    plt.ylabel('Rata-rata G3')

plt.tight_layout()
plt.show()

"""### Numerical Features"""

# Mengamati hubungan antar fitur numerik dengan fungsi pairplot()
sns.pairplot(student, diag_kind = 'kde')

plt.figure(figsize=(10, 8))
correlation_matrix = student[numerical_features].corr().round(2)

# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
sns.heatmap(data=correlation_matrix, annot=True, cmap=sns.color_palette("Blues", as_cmap=True) )
plt.title("Korelasi Matrix untuk Fitur Numerik ", size=20)

"""Berdasarkan hasil korelasi matrix diatas,

* Nilai Ujian (G1, G2, G3) memiliki korelasi yang sangat kuat satu sama lain, menunjukkan bahwa performa siswa pada semester sebelumnya dapat menjadi indikator performa di semester berikutnya.
* Pendidikan Orang Tua (Medu dan Fedu) juga memiliki korelasi yang cukup kuat, yang bisa menunjukkan bahwa orang tua dengan tingkat pendidikan tinggi cenderung menikah dengan pasangan dengan tingkat pendidikan yang sama.
* Usia tidak terlalu berkorelasi dengan variabel lain, yang berarti faktor usia tidak terlalu berpengaruh terhadap nilai siswa atau pendidikan orang tua.

## Data Preparation
"""

from sklearn.preprocessing import OneHotEncoder

encoder = OneHotEncoder(sparse_output=False, handle_unknown='ignore')

encoded_data = encoder.fit_transform(student[categorical_features])
encoded_df = pd.DataFrame(encoded_data, columns=encoder.get_feature_names_out(categorical_features))

student_encoded = pd.concat([student, encoded_df], axis=1)

student_encoded.head()

"""## Split Dataset"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

student_encoded_cleaned = student_encoded.copy()

string_columns = student_encoded_cleaned.select_dtypes(include=['object']).columns

if not string_columns.empty:
    print(f"Kolom yang masih berupa string dan akan diubah: {list(string_columns)}")

    student_encoded_cleaned[string_columns] = student_encoded_cleaned[string_columns].apply(lambda col: col.astype('category').cat.codes)

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""## Model Development"""

# Training Model: Linear Regression
lin_reg = LinearRegression()
lin_reg.fit(X_train_scaled, y_train)
y_pred_lin = lin_reg.predict(X_test_scaled)

# Evaluasi Linear Regression
mae_lin = mean_absolute_error(y_test, y_pred_lin)
mse_lin = mean_squared_error(y_test, y_pred_lin)
r2_lin = r2_score(y_test, y_pred_lin)

print(f"Linear Regression - MAE: {mae_lin:.2f}, MSE: {mse_lin:.2f}, R²: {r2_lin:.2f}")

# Training Model: Decision Tree Regressor
tree_reg = DecisionTreeRegressor(random_state=123)
tree_reg.fit(X_train_scaled, y_train)
y_pred_tree = tree_reg.predict(X_test_scaled)

# Evaluasi Decision Tree
mae_tree = mean_absolute_error(y_test, y_pred_tree)
mse_tree = mean_squared_error(y_test, y_pred_tree)
r2_tree = r2_score(y_test, y_pred_tree)

print(f"Decision Tree - MAE: {mae_tree:.2f}, MSE: {mse_tree:.2f}, R²: {r2_tree:.2f}")

# Training Model: Random Forest Regressor
forest_reg = RandomForestRegressor(random_state=123)
forest_reg.fit(X_train_scaled, y_train)
y_pred_forest = forest_reg.predict(X_test_scaled)

# Evaluasi Random Forest
mae_forest = mean_absolute_error(y_test, y_pred_forest)
mse_forest = mean_squared_error(y_test, y_pred_forest)
r2_forest = r2_score(y_test, y_pred_forest)

print(f"Random Forest - MAE: {mae_forest:.2f}, MSE: {mse_forest:.2f}, R²: {r2_forest:.2f}")

# Training Model: Support Vector Regressor
svr_model = SVR()
svr_model.fit(X_train_scaled, y_train)
y_pred_svr = svr_model.predict(X_test_scaled)

# Evaluasi SVR
mae_svr = mean_absolute_error(y_test, y_pred_svr)
mse_svr = mean_squared_error(y_test, y_pred_svr)
r2_svr = r2_score(y_test, y_pred_svr)

print(f"SVR - MAE: {mae_svr:.2f}, MSE: {mse_svr:.2f}, R²: {r2_svr:.2f}")

"""## Model Evaluation"""

def evaluate_model(model_name, y_true, y_pred):
    mae = mean_absolute_error(y_true, y_pred)
    mse = mean_squared_error(y_true, y_pred)
    r2 = r2_score(y_true, y_pred)
    print(f"\n{model_name} - Evaluation Metrics:")
    print(f"MAE: {mae:.2f}")
    print(f"MSE: {mse:.2f}")
    print(f"R²: {r2:.2f}")
    return mae, mse, r2

# Evaluasi Model Linear Regression
mae_lin, mse_lin, r2_lin = evaluate_model("Linear Regression", y_test, y_pred_lin)

# Evaluasi Model Decision Tree
mae_tree, mse_tree, r2_tree = evaluate_model("Decision Tree Regressor", y_test, y_pred_tree)

# Evaluasi Model Random Forest
mae_forest, mse_forest, r2_forest = evaluate_model("Random Forest Regressor", y_test, y_pred_forest)

# Evaluasi Model SVR
mae_svr, mse_svr, r2_svr = evaluate_model("Support Vector Regressor", y_test, y_pred_svr)

results_df = pd.DataFrame({
    'Model': ['Linear Regression', 'Decision Tree', 'Random Forest', 'SVR'],
    'MAE': [mae_lin, mae_tree, mae_forest, mae_svr],
    'MSE': [mse_lin, mse_tree, mse_forest, mse_svr],
    'R²': [r2_lin, r2_tree, r2_forest, r2_svr]
})

print("\nHasil Evaluasi Model:\n")
print(results_df)

plt.figure(figsize=(14, 6))
plt.subplot(1, 2, 1)
results_df.set_index('Model')[['MAE', 'MSE']].plot(kind='bar',ax=plt.gca())
plt.title('Perbandingan Error Model (MAE dan MSE)')
plt.ylabel('Error')
plt.grid(True)
plt.xticks(rotation=0)

# Bar plot untuk R²
plt.figure(figsize=(14, 6))
plt.subplot(1, 2, 2)
results_df.set_index('Model')['R²'].plot(kind='bar', ax=plt.gca())
plt.title('Perbandingan R² Model')
plt.ylabel('R² Score')
plt.grid(True)
plt.xticks(rotation=0)

plt.tight_layout()
plt.show()